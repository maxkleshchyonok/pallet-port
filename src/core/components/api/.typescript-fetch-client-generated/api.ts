/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * Palletport API
 * Palletport API
 *
 * OpenAPI spec version: 1
 * Contact: foteev@gmail.com
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from "url";
import * as isomorphicFetch from "isomorphic-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "https://virtserver.swaggerhub.com/FOTEEV_1/1234/1".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = isomorphicFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface Address
 */
export interface Address {
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    street?: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    city: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    zipCode: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    state: string;
    /**
     * 
     * @type {string}
     * @memberof Address
     */
    countryCode: string;
    /**
     * 
     * @type {Coordinates}
     * @memberof Address
     */
    coordinates?: Coordinates;
}
/**
 * 
 * @export
 * @interface Cart
 */
export interface Cart {
    /**
     * 
     * @type {number}
     * @memberof Cart
     */
    id?: number;
    /**
     * 
     * @type {User}
     * @memberof Cart
     */
    user?: User;
    /**
     * 
     * @type {Array<CartOffers>}
     * @memberof Cart
     */
    offers?: Array<CartOffers>;
}
/**
 * 
 * @export
 * @interface CartOffers
 */
export interface CartOffers {
    /**
     * 
     * @type {Offer}
     * @memberof CartOffers
     */
    offer?: Offer;
    /**
     * 
     * @type {number}
     * @memberof CartOffers
     */
    quantity?: number;
    /**
     * 
     * @type {Delivery}
     * @memberof CartOffers
     */
    delivery?: Delivery;
}
/**
 * 
 * @export
 * @interface Company
 */
export interface Company {
    /**
     * 
     * @type {number}
     * @memberof Company
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Company
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Company
     */
    NIP?: string;
    /**
     * 
     * @type {Address}
     * @memberof Company
     */
    address?: Address;
    /**
     * 
     * @type {string}
     * @memberof Company
     */
    IBAN?: string;
    /**
     * 
     * @type {number}
     * @memberof Company
     */
    paymentDate?: number;
    /**
     * 
     * @type {number}
     * @memberof Company
     */
    VAT?: number;
    /**
     * 
     * @type {string}
     * @memberof Company
     */
    email?: string;
    /**
     * 
     * @type {string}
     * @memberof Company
     */
    phone?: string;
    /**
     * 
     * @type {number}
     * @memberof Company
     */
    workingHourMin?: number;
    /**
     * 
     * @type {number}
     * @memberof Company
     */
    workingHourMax?: number;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum Condition {
    NEW = <any> 'NEW',
    USED1CATEGORY = <any> 'USED 1 CATEGORY',
    USED2CATEGORY = <any> 'USED 2 CATEGORY',
    USED3CATEGORY = <any> 'USED 3 CATEGORY',
    BROKEN = <any> 'BROKEN'
}
/**
 * 
 * @export
 * @interface Coordinates
 */
export interface Coordinates {
}
/**
 * 
 * @export
 * @interface Delivery
 */
export interface Delivery {
    /**
     * 
     * @type {DeliveryType}
     * @memberof Delivery
     */
    deliveryType?: DeliveryType;
    /**
     * 
     * @type {number}
     * @memberof Delivery
     */
    deliveryTimeMin?: number;
    /**
     * 
     * @type {number}
     * @memberof Delivery
     */
    deliveryTimeMax?: number;
    /**
     * 
     * @type {number}
     * @memberof Delivery
     */
    deliveryPrice?: number;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum DeliveryType {
    SELFPICKUP = <any> 'SELFPICKUP',
    BUS = <any> 'BUS',
    TRUCK = <any> 'TRUCK',
    COURIER = <any> 'COURIER'
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum Material {
    METAL = <any> 'METAL',
    PLASTIC = <any> 'PLASTIC',
    WOOD = <any> 'WOOD',
    CARDBOARD = <any> 'CARDBOARD'
}
/**
 * 
 * @export
 * @interface Offer
 */
export interface Offer {
    /**
     * 
     * @type {number}
     * @memberof Offer
     */
    id?: number;
    /**
     * 
     * @type {Product}
     * @memberof Offer
     */
    product?: Product;
    /**
     * 
     * @type {User}
     * @memberof Offer
     */
    seller?: User;
    /**
     * 
     * @type {Company}
     * @memberof Offer
     */
    company?: Company;
    /**
     * 
     * @type {number}
     * @memberof Offer
     */
    price?: number;
    /**
     * 
     * @type {number}
     * @memberof Offer
     */
    quantityMin?: number;
    /**
     * 
     * @type {number}
     * @memberof Offer
     */
    quantityMax?: number;
    /**
     * 
     * @type {Array<Delivery>}
     * @memberof Offer
     */
    delivery?: Array<Delivery>;
    /**
     * 
     * @type {string}
     * @memberof Offer
     */
    image1?: string;
    /**
     * 
     * @type {string}
     * @memberof Offer
     */
    image2?: string;
    /**
     * 
     * @type {string}
     * @memberof Offer
     */
    description?: string;
    /**
     * 
     * @type {OfferStatus}
     * @memberof Offer
     */
    offerStatus?: OfferStatus;
    /**
     * 
     * @type {number}
     * @memberof Offer
     */
    rating?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Offer
     */
    isTop?: boolean;
}
/**
 * 
 * @export
 * @interface OfferImageLinkUploadRequest
 */
export interface OfferImageLinkUploadRequest {
    /**
     * URL of the image. It has to contain domain name, not an IP address. Currently we support http and https protocols. When using https the certificate chain needs to be valid.
     * @type {string}
     * @memberof OfferImageLinkUploadRequest
     */
    url: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum OfferStatus {
    ACTIVE = <any> 'ACTIVE',
    MODERATION = <any> 'MODERATION',
    CLOSED = <any> 'CLOSED'
}
/**
 * 
 * @export
 * @interface Order
 */
export interface Order {
    /**
     * 
     * @type {number}
     * @memberof Order
     */
    id?: number;
    /**
     * 
     * @type {Cart}
     * @memberof Order
     */
    cart?: Cart;
    /**
     * 
     * @type {OrderStatus}
     * @memberof Order
     */
    status?: OrderStatus;
    /**
     * 
     * @type {PaymentType}
     * @memberof Order
     */
    payment?: PaymentType;
    /**
     * 
     * @type {boolean}
     * @memberof Order
     */
    paymentStatus?: boolean;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum OrderStatus {
    CREATED = <any> 'CREATED',
    MODERATION = <any> 'MODERATION',
    PENDING = <any> 'PENDING',
    ACCEPTED = <any> 'ACCEPTED',
    SENDED = <any> 'SENDED',
    DELIVERED = <any> 'DELIVERED',
    RETURNED = <any> 'RETURNED',
    CLOSED = <any> 'CLOSED'
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum PaymentType {
    CASH = <any> 'CASH',
    INVOICE = <any> 'INVOICE',
    CARD = <any> 'CARD'
}
/**
 * 
 * @export
 * @interface Product
 */
export interface Product {
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    name?: string;
    /**
     * 
     * @type {Material}
     * @memberof Product
     */
    material?: Material;
    /**
     * 
     * @type {Condition}
     * @memberof Product
     */
    condition?: Condition;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    image1?: string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    image2?: string;
    /**
     * 
     * @type {string}
     * @memberof Product
     */
    shortName?: string;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    length?: number;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    width?: number;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    height?: number;
    /**
     * 
     * @type {number}
     * @memberof Product
     */
    maxLoad?: number;
    /**
     * 
     * @type {ProductCategory}
     * @memberof Product
     */
    category?: ProductCategory;
}
/**
 * 
 * @export
 * @interface ProductCategory
 */
export interface ProductCategory {
    /**
     * 
     * @type {number}
     * @memberof ProductCategory
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof ProductCategory
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductCategory
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductCategory
     */
    image?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductCategory
     */
    shortName?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */
export enum Role {
    BUYER = <any> 'BUYER',
    SELLER = <any> 'SELLER',
    ADMIN = <any> 'ADMIN',
    SYSTEM = <any> 'SYSTEM',
    LOGISTIC = <any> 'LOGISTIC'
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {number}
     * @memberof User
     */
    id?: number;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    name?: string;
    /**
     * unique
     * @type {string}
     * @memberof User
     */
    email: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    password?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    phone?: string;
    /**
     * 
     * @type {number}
     * @memberof User
     */
    rank?: number;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    avatar?: string;
    /**
     * 
     * @type {Array<Role>}
     * @memberof User
     */
    roles?: Array<Role>;
    /**
     * 
     * @type {Address}
     * @memberof User
     */
    deliveryAddress?: Address;
    /**
     * 
     * @type {Address}
     * @memberof User
     */
    paymentAddress?: Address;
    /**
     * 
     * @type {Array<Company>}
     * @memberof User
     */
    companies?: Array<Company>;
}
/**
 * OfferApi - fetch parameter creator
 * @export
 */
export const OfferApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Use this resource to create offer based on product. Read more: <a href=\"../../tutorials/jak-jednym-requestem-wystawic-oferte-powiazana-z-produktem-D7Kj9gw4xFA#jak-wystawic-oferte-z-produktem-za-pomoca-zasobu-sale-product-offers\" target=\"_blank\">PL</a> / <a href=\"../../tutorials/list-offer-assigned-product-one-request-D7Kj9M71Bu6#how-to-list-an-offer-with-a-product-via-sale-product-offers-resource\" target=\"_blank\">EN</a>. Note that requests may be limited.
         * @summary Create offer based on product
         * @param {Offer} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProductOffers(body: Offer, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createProductOffers.');
            }
            const localVarPath = `/offers`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Offer" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Use this resource to delete a draft offer. Read more: <a href=\"../../news/nowy-zasob-do-usuwania-draftow-ofert-aMDnGka2RuL\" target=\"_blank\">PL</a> / <a href=\"../../news/new-resource-draft-delete-yPy9lq6myh0\" target=\"_blank\">EN</a>.
         * @summary Delete a draft offer
         * @param {string} offerId Offer identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOfferUsingDELETE(offerId: string, options: any = {}): FetchArgs {
            // verify required parameter 'offerId' is not null or undefined
            if (offerId === null || offerId === undefined) {
                throw new RequiredError('offerId','Required parameter offerId was null or undefined when calling deleteOfferUsingDELETE.');
            }
            const localVarPath = `/offers/{offerId}`
                .replace(`{${"offerId"}}`, encodeURIComponent(String(offerId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Finds offers by userEmail
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOfferByUserEmail(email: string, options: any = {}): FetchArgs {
            // verify required parameter 'email' is not null or undefined
            if (email === null || email === undefined) {
                throw new RequiredError('email','Required parameter email was null or undefined when calling findOfferByUserEmail.');
            }
            const localVarPath = `/offers/findByUser`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Multiple status values can be provided with comma separated strings
         * @summary Finds offer by status
         * @param {Array<OfferStatus>} status Status values that need to be considered for filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOffersByStatus(status: Array<OfferStatus>, options: any = {}): FetchArgs {
            // verify required parameter 'status' is not null or undefined
            if (status === null || status === undefined) {
                throw new RequiredError('status','Required parameter status was null or undefined when calling findOffersByStatus.');
            }
            const localVarPath = `/offers/findByStatus`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (status) {
                localVarQueryParameter['status'] = status;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a offer in the store with form data
         * @param {Offer} body Offer object that needs to be added to the marketplace
         * @param {number} offerId ID of offer that needs to be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOffertWithForm(body: Offer, offerId: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateOffertWithForm.');
            }
            // verify required parameter 'offerId' is not null or undefined
            if (offerId === null || offerId === undefined) {
                throw new RequiredError('offerId','Required parameter offerId was null or undefined when calling updateOffertWithForm.');
            }
            const localVarPath = `/offers/{offerId}`
                .replace(`{${"offerId"}}`, encodeURIComponent(String(offerId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Offer" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary uploads an image
         * @param {number} offerId ID of offer to update
         * @param {Object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFile(offerId: number, body?: Object, options: any = {}): FetchArgs {
            // verify required parameter 'offerId' is not null or undefined
            if (offerId === null || offerId === undefined) {
                throw new RequiredError('offerId','Required parameter offerId was null or undefined when calling uploadFile.');
            }
            const localVarPath = `/offers/{offerId}/uploadImage`
                .replace(`{${"offerId"}}`, encodeURIComponent(String(offerId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/octet-stream';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Object" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OfferApi - functional programming interface
 * @export
 */
export const OfferApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Use this resource to create offer based on product. Read more: <a href=\"../../tutorials/jak-jednym-requestem-wystawic-oferte-powiazana-z-produktem-D7Kj9gw4xFA#jak-wystawic-oferte-z-produktem-za-pomoca-zasobu-sale-product-offers\" target=\"_blank\">PL</a> / <a href=\"../../tutorials/list-offer-assigned-product-one-request-D7Kj9M71Bu6#how-to-list-an-offer-with-a-product-via-sale-product-offers-resource\" target=\"_blank\">EN</a>. Note that requests may be limited.
         * @summary Create offer based on product
         * @param {Offer} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProductOffers(body: Offer, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = OfferApiFetchParamCreator(configuration).createProductOffers(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Use this resource to delete a draft offer. Read more: <a href=\"../../news/nowy-zasob-do-usuwania-draftow-ofert-aMDnGka2RuL\" target=\"_blank\">PL</a> / <a href=\"../../news/new-resource-draft-delete-yPy9lq6myh0\" target=\"_blank\">EN</a>.
         * @summary Delete a draft offer
         * @param {string} offerId Offer identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOfferUsingDELETE(offerId: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = OfferApiFetchParamCreator(configuration).deleteOfferUsingDELETE(offerId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Finds offers by userEmail
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOfferByUserEmail(email: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Offer>> {
            const localVarFetchArgs = OfferApiFetchParamCreator(configuration).findOfferByUserEmail(email, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Multiple status values can be provided with comma separated strings
         * @summary Finds offer by status
         * @param {Array<OfferStatus>} status Status values that need to be considered for filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOffersByStatus(status: Array<OfferStatus>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Offer>> {
            const localVarFetchArgs = OfferApiFetchParamCreator(configuration).findOffersByStatus(status, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates a offer in the store with form data
         * @param {Offer} body Offer object that needs to be added to the marketplace
         * @param {number} offerId ID of offer that needs to be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOffertWithForm(body: Offer, offerId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = OfferApiFetchParamCreator(configuration).updateOffertWithForm(body, offerId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary uploads an image
         * @param {number} offerId ID of offer to update
         * @param {Object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFile(offerId: number, body?: Object, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = OfferApiFetchParamCreator(configuration).uploadFile(offerId, body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * OfferApi - factory interface
 * @export
 */
export const OfferApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Use this resource to create offer based on product. Read more: <a href=\"../../tutorials/jak-jednym-requestem-wystawic-oferte-powiazana-z-produktem-D7Kj9gw4xFA#jak-wystawic-oferte-z-produktem-za-pomoca-zasobu-sale-product-offers\" target=\"_blank\">PL</a> / <a href=\"../../tutorials/list-offer-assigned-product-one-request-D7Kj9M71Bu6#how-to-list-an-offer-with-a-product-via-sale-product-offers-resource\" target=\"_blank\">EN</a>. Note that requests may be limited.
         * @summary Create offer based on product
         * @param {Offer} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProductOffers(body: Offer, options?: any) {
            return OfferApiFp(configuration).createProductOffers(body, options)(fetch, basePath);
        },
        /**
         * Use this resource to delete a draft offer. Read more: <a href=\"../../news/nowy-zasob-do-usuwania-draftow-ofert-aMDnGka2RuL\" target=\"_blank\">PL</a> / <a href=\"../../news/new-resource-draft-delete-yPy9lq6myh0\" target=\"_blank\">EN</a>.
         * @summary Delete a draft offer
         * @param {string} offerId Offer identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOfferUsingDELETE(offerId: string, options?: any) {
            return OfferApiFp(configuration).deleteOfferUsingDELETE(offerId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Finds offers by userEmail
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOfferByUserEmail(email: string, options?: any) {
            return OfferApiFp(configuration).findOfferByUserEmail(email, options)(fetch, basePath);
        },
        /**
         * Multiple status values can be provided with comma separated strings
         * @summary Finds offer by status
         * @param {Array<OfferStatus>} status Status values that need to be considered for filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOffersByStatus(status: Array<OfferStatus>, options?: any) {
            return OfferApiFp(configuration).findOffersByStatus(status, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates a offer in the store with form data
         * @param {Offer} body Offer object that needs to be added to the marketplace
         * @param {number} offerId ID of offer that needs to be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOffertWithForm(body: Offer, offerId: number, options?: any) {
            return OfferApiFp(configuration).updateOffertWithForm(body, offerId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary uploads an image
         * @param {number} offerId ID of offer to update
         * @param {Object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFile(offerId: number, body?: Object, options?: any) {
            return OfferApiFp(configuration).uploadFile(offerId, body, options)(fetch, basePath);
        },
    };
};

/**
 * OfferApi - object-oriented interface
 * @export
 * @class OfferApi
 * @extends {BaseAPI}
 */
export class OfferApi extends BaseAPI {
    /**
     * Use this resource to create offer based on product. Read more: <a href=\"../../tutorials/jak-jednym-requestem-wystawic-oferte-powiazana-z-produktem-D7Kj9gw4xFA#jak-wystawic-oferte-z-produktem-za-pomoca-zasobu-sale-product-offers\" target=\"_blank\">PL</a> / <a href=\"../../tutorials/list-offer-assigned-product-one-request-D7Kj9M71Bu6#how-to-list-an-offer-with-a-product-via-sale-product-offers-resource\" target=\"_blank\">EN</a>. Note that requests may be limited.
     * @summary Create offer based on product
     * @param {Offer} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OfferApi
     */
    public createProductOffers(body: Offer, options?: any) {
        return OfferApiFp(this.configuration).createProductOffers(body, options)(this.fetch, this.basePath);
    }

    /**
     * Use this resource to delete a draft offer. Read more: <a href=\"../../news/nowy-zasob-do-usuwania-draftow-ofert-aMDnGka2RuL\" target=\"_blank\">PL</a> / <a href=\"../../news/new-resource-draft-delete-yPy9lq6myh0\" target=\"_blank\">EN</a>.
     * @summary Delete a draft offer
     * @param {string} offerId Offer identifier.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OfferApi
     */
    public deleteOfferUsingDELETE(offerId: string, options?: any) {
        return OfferApiFp(this.configuration).deleteOfferUsingDELETE(offerId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Finds offers by userEmail
     * @param {string} email 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OfferApi
     */
    public findOfferByUserEmail(email: string, options?: any) {
        return OfferApiFp(this.configuration).findOfferByUserEmail(email, options)(this.fetch, this.basePath);
    }

    /**
     * Multiple status values can be provided with comma separated strings
     * @summary Finds offer by status
     * @param {Array<OfferStatus>} status Status values that need to be considered for filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OfferApi
     */
    public findOffersByStatus(status: Array<OfferStatus>, options?: any) {
        return OfferApiFp(this.configuration).findOffersByStatus(status, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates a offer in the store with form data
     * @param {Offer} body Offer object that needs to be added to the marketplace
     * @param {number} offerId ID of offer that needs to be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OfferApi
     */
    public updateOffertWithForm(body: Offer, offerId: number, options?: any) {
        return OfferApiFp(this.configuration).updateOffertWithForm(body, offerId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary uploads an image
     * @param {number} offerId ID of offer to update
     * @param {Object} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OfferApi
     */
    public uploadFile(offerId: number, body?: Object, options?: any) {
        return OfferApiFp(this.configuration).uploadFile(offerId, body, options)(this.fetch, this.basePath);
    }

}
/**
 * OrderApi - fetch parameter creator
 * @export
 */
export const OrderApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * For valid response try integer IDs with positive integer value.\\ \\ Negative or non-integer values will generate API errors
         * @summary Delete purchase order by ID
         * @param {number} orderId ID of the order that needs to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrder(orderId: number, options: any = {}): FetchArgs {
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling deleteOrder.');
            }
            const localVarPath = `/orders/{orderId}`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Multiple status values can be provided with comma separated strings
         * @summary Finds order by status
         * @param {Array<OrderStatus>} status Status values that need to be considered for filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOrdersByStatus(status: Array<OrderStatus>, options: any = {}): FetchArgs {
            // verify required parameter 'status' is not null or undefined
            if (status === null || status === undefined) {
                throw new RequiredError('status','Required parameter status was null or undefined when calling findOrdersByStatus.');
            }
            const localVarPath = `/orders/findByStatus`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (status) {
                localVarQueryParameter['status'] = status;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Finds orders by userEmail
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOrdersByUserEmail(email: string, options: any = {}): FetchArgs {
            // verify required parameter 'email' is not null or undefined
            if (email === null || email === undefined) {
                throw new RequiredError('email','Required parameter email was null or undefined when calling findOrdersByUserEmail.');
            }
            const localVarPath = `/orders/findByUser`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (email !== undefined) {
                localVarQueryParameter['email'] = email;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * For valid response try integer IDs with value >= 1 and <= 10.\\ \\ Other values will generated exceptions
         * @summary Find purchase order by ID
         * @param {number} orderId ID of order that needs to be fetched
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderById(orderId: number, options: any = {}): FetchArgs {
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling getOrderById.');
            }
            const localVarPath = `/orders/{orderId}`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Place an order
         * @param {Order} body order placed for purchasing
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placeOrder(body: Order, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling placeOrder.');
            }
            const localVarPath = `/orders`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Order" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a order in the store with form data
         * @param {Order} body Order object that needs to be added to the marketplace
         * @param {number} orderId ID of order that needs to be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrderWithForm(body: Order, orderId: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateOrderWithForm.');
            }
            // verify required parameter 'orderId' is not null or undefined
            if (orderId === null || orderId === undefined) {
                throw new RequiredError('orderId','Required parameter orderId was null or undefined when calling updateOrderWithForm.');
            }
            const localVarPath = `/orders/{orderId}`
                .replace(`{${"orderId"}}`, encodeURIComponent(String(orderId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Order" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrderApi - functional programming interface
 * @export
 */
export const OrderApiFp = function(configuration?: Configuration) {
    return {
        /**
         * For valid response try integer IDs with positive integer value.\\ \\ Negative or non-integer values will generate API errors
         * @summary Delete purchase order by ID
         * @param {number} orderId ID of the order that needs to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrder(orderId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = OrderApiFetchParamCreator(configuration).deleteOrder(orderId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Multiple status values can be provided with comma separated strings
         * @summary Finds order by status
         * @param {Array<OrderStatus>} status Status values that need to be considered for filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOrdersByStatus(status: Array<OrderStatus>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Order>> {
            const localVarFetchArgs = OrderApiFetchParamCreator(configuration).findOrdersByStatus(status, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Finds orders by userEmail
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOrdersByUserEmail(email: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Order>> {
            const localVarFetchArgs = OrderApiFetchParamCreator(configuration).findOrdersByUserEmail(email, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * For valid response try integer IDs with value >= 1 and <= 10.\\ \\ Other values will generated exceptions
         * @summary Find purchase order by ID
         * @param {number} orderId ID of order that needs to be fetched
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderById(orderId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Order> {
            const localVarFetchArgs = OrderApiFetchParamCreator(configuration).getOrderById(orderId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Place an order
         * @param {Order} body order placed for purchasing
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placeOrder(body: Order, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Order> {
            const localVarFetchArgs = OrderApiFetchParamCreator(configuration).placeOrder(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates a order in the store with form data
         * @param {Order} body Order object that needs to be added to the marketplace
         * @param {number} orderId ID of order that needs to be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrderWithForm(body: Order, orderId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = OrderApiFetchParamCreator(configuration).updateOrderWithForm(body, orderId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * OrderApi - factory interface
 * @export
 */
export const OrderApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * For valid response try integer IDs with positive integer value.\\ \\ Negative or non-integer values will generate API errors
         * @summary Delete purchase order by ID
         * @param {number} orderId ID of the order that needs to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrder(orderId: number, options?: any) {
            return OrderApiFp(configuration).deleteOrder(orderId, options)(fetch, basePath);
        },
        /**
         * Multiple status values can be provided with comma separated strings
         * @summary Finds order by status
         * @param {Array<OrderStatus>} status Status values that need to be considered for filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOrdersByStatus(status: Array<OrderStatus>, options?: any) {
            return OrderApiFp(configuration).findOrdersByStatus(status, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Finds orders by userEmail
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findOrdersByUserEmail(email: string, options?: any) {
            return OrderApiFp(configuration).findOrdersByUserEmail(email, options)(fetch, basePath);
        },
        /**
         * For valid response try integer IDs with value >= 1 and <= 10.\\ \\ Other values will generated exceptions
         * @summary Find purchase order by ID
         * @param {number} orderId ID of order that needs to be fetched
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderById(orderId: number, options?: any) {
            return OrderApiFp(configuration).getOrderById(orderId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Place an order
         * @param {Order} body order placed for purchasing
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        placeOrder(body: Order, options?: any) {
            return OrderApiFp(configuration).placeOrder(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates a order in the store with form data
         * @param {Order} body Order object that needs to be added to the marketplace
         * @param {number} orderId ID of order that needs to be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrderWithForm(body: Order, orderId: number, options?: any) {
            return OrderApiFp(configuration).updateOrderWithForm(body, orderId, options)(fetch, basePath);
        },
    };
};

/**
 * OrderApi - object-oriented interface
 * @export
 * @class OrderApi
 * @extends {BaseAPI}
 */
export class OrderApi extends BaseAPI {
    /**
     * For valid response try integer IDs with positive integer value.\\ \\ Negative or non-integer values will generate API errors
     * @summary Delete purchase order by ID
     * @param {number} orderId ID of the order that needs to be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public deleteOrder(orderId: number, options?: any) {
        return OrderApiFp(this.configuration).deleteOrder(orderId, options)(this.fetch, this.basePath);
    }

    /**
     * Multiple status values can be provided with comma separated strings
     * @summary Finds order by status
     * @param {Array<OrderStatus>} status Status values that need to be considered for filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public findOrdersByStatus(status: Array<OrderStatus>, options?: any) {
        return OrderApiFp(this.configuration).findOrdersByStatus(status, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Finds orders by userEmail
     * @param {string} email 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public findOrdersByUserEmail(email: string, options?: any) {
        return OrderApiFp(this.configuration).findOrdersByUserEmail(email, options)(this.fetch, this.basePath);
    }

    /**
     * For valid response try integer IDs with value >= 1 and <= 10.\\ \\ Other values will generated exceptions
     * @summary Find purchase order by ID
     * @param {number} orderId ID of order that needs to be fetched
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public getOrderById(orderId: number, options?: any) {
        return OrderApiFp(this.configuration).getOrderById(orderId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Place an order
     * @param {Order} body order placed for purchasing
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public placeOrder(body: Order, options?: any) {
        return OrderApiFp(this.configuration).placeOrder(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates a order in the store with form data
     * @param {Order} body Order object that needs to be added to the marketplace
     * @param {number} orderId ID of order that needs to be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public updateOrderWithForm(body: Order, orderId: number, options?: any) {
        return OrderApiFp(this.configuration).updateOrderWithForm(body, orderId, options)(this.fetch, this.basePath);
    }

}
/**
 * ProductApi - fetch parameter creator
 * @export
 */
export const ProductApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add a new product to marketplace
         * @param {Product} body Product object that needs to be added to the marketplace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addProduct(body: Product, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling addProduct.');
            }
            const localVarPath = `/products`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Product" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes a product
         * @param {number} productId Product id to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProduct(productId: number, options: any = {}): FetchArgs {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling deleteProduct.');
            }
            const localVarPath = `/products/{productId}`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication palletport_auth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("palletport_auth", ["write:product", "read:product"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single product
         * @summary Find product by ID
         * @param {number} productId ID of product to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductById(productId: number, options: any = {}): FetchArgs {
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling getProductById.');
            }
            const localVarPath = `/products/{productId}`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a product in the store with form data
         * @param {Product} body Product object that needs to be added to the marketplace
         * @param {number} productId ID of product that needs to be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProductWithForm(body: Product, productId: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateProductWithForm.');
            }
            // verify required parameter 'productId' is not null or undefined
            if (productId === null || productId === undefined) {
                throw new RequiredError('productId','Required parameter productId was null or undefined when calling updateProductWithForm.');
            }
            const localVarPath = `/products/{productId}`
                .replace(`{${"productId"}}`, encodeURIComponent(String(productId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"Product" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductApi - functional programming interface
 * @export
 */
export const ProductApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add a new product to marketplace
         * @param {Product} body Product object that needs to be added to the marketplace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addProduct(body: Product, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProductApiFetchParamCreator(configuration).addProduct(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Deletes a product
         * @param {number} productId Product id to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProduct(productId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProductApiFetchParamCreator(configuration).deleteProduct(productId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns a single product
         * @summary Find product by ID
         * @param {number} productId ID of product to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductById(productId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Product> {
            const localVarFetchArgs = ProductApiFetchParamCreator(configuration).getProductById(productId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates a product in the store with form data
         * @param {Product} body Product object that needs to be added to the marketplace
         * @param {number} productId ID of product that needs to be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProductWithForm(body: Product, productId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProductApiFetchParamCreator(configuration).updateProductWithForm(body, productId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ProductApi - factory interface
 * @export
 */
export const ProductApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Add a new product to marketplace
         * @param {Product} body Product object that needs to be added to the marketplace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addProduct(body: Product, options?: any) {
            return ProductApiFp(configuration).addProduct(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Deletes a product
         * @param {number} productId Product id to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProduct(productId: number, options?: any) {
            return ProductApiFp(configuration).deleteProduct(productId, options)(fetch, basePath);
        },
        /**
         * Returns a single product
         * @summary Find product by ID
         * @param {number} productId ID of product to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductById(productId: number, options?: any) {
            return ProductApiFp(configuration).getProductById(productId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates a product in the store with form data
         * @param {Product} body Product object that needs to be added to the marketplace
         * @param {number} productId ID of product that needs to be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProductWithForm(body: Product, productId: number, options?: any) {
            return ProductApiFp(configuration).updateProductWithForm(body, productId, options)(fetch, basePath);
        },
    };
};

/**
 * ProductApi - object-oriented interface
 * @export
 * @class ProductApi
 * @extends {BaseAPI}
 */
export class ProductApi extends BaseAPI {
    /**
     * 
     * @summary Add a new product to marketplace
     * @param {Product} body Product object that needs to be added to the marketplace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public addProduct(body: Product, options?: any) {
        return ProductApiFp(this.configuration).addProduct(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Deletes a product
     * @param {number} productId Product id to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public deleteProduct(productId: number, options?: any) {
        return ProductApiFp(this.configuration).deleteProduct(productId, options)(this.fetch, this.basePath);
    }

    /**
     * Returns a single product
     * @summary Find product by ID
     * @param {number} productId ID of product to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public getProductById(productId: number, options?: any) {
        return ProductApiFp(this.configuration).getProductById(productId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates a product in the store with form data
     * @param {Product} body Product object that needs to be added to the marketplace
     * @param {number} productId ID of product that needs to be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductApi
     */
    public updateProductWithForm(body: Product, productId: number, options?: any) {
        return ProductApiFp(this.configuration).updateProductWithForm(body, productId, options)(this.fetch, this.basePath);
    }

}
/**
 * ProductCategoryApi - fetch parameter creator
 * @export
 */
export const ProductCategoryApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add a new product Category to marketplace
         * @param {ProductCategory} body ProductCategory object that needs to be added to the marketplace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addProductCategory(body: ProductCategory, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling addProductCategory.');
            }
            const localVarPath = `/productCategories`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ProductCategory" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Deletes a product Category
         * @param {number} productCategoryId Product Category id to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductCategory(productCategoryId: number, options: any = {}): FetchArgs {
            // verify required parameter 'productCategoryId' is not null or undefined
            if (productCategoryId === null || productCategoryId === undefined) {
                throw new RequiredError('productCategoryId','Required parameter productCategoryId was null or undefined when calling deleteProductCategory.');
            }
            const localVarPath = `/productCategories/{productCategoryId}`
                .replace(`{${"productCategoryId"}}`, encodeURIComponent(String(productCategoryId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication palletport_auth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("palletport_auth", ["write:product", "read:product"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a single product Category
         * @summary Find product Category by ID
         * @param {number} productCategoryId ID of product Category to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductCategoryById(productCategoryId: number, options: any = {}): FetchArgs {
            // verify required parameter 'productCategoryId' is not null or undefined
            if (productCategoryId === null || productCategoryId === undefined) {
                throw new RequiredError('productCategoryId','Required parameter productCategoryId was null or undefined when calling getProductCategoryById.');
            }
            const localVarPath = `/productCategories/{productCategoryId}`
                .replace(`{${"productCategoryId"}}`, encodeURIComponent(String(productCategoryId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("api_key")
					: configuration.apiKey;
                localVarHeaderParameter["api_key"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Updates a product Category in the store with form data
         * @param {ProductCategory} body ProductCategory object that needs to be added to the marketplace
         * @param {number} productCategoryId ID of product Category that needs to be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProductCategoryWithForm(body: ProductCategory, productCategoryId: number, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateProductCategoryWithForm.');
            }
            // verify required parameter 'productCategoryId' is not null or undefined
            if (productCategoryId === null || productCategoryId === undefined) {
                throw new RequiredError('productCategoryId','Required parameter productCategoryId was null or undefined when calling updateProductCategoryWithForm.');
            }
            const localVarPath = `/productCategories/{productCategoryId}`
                .replace(`{${"productCategoryId"}}`, encodeURIComponent(String(productCategoryId)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication palletport_auth required
            // oauth required
            if (configuration && configuration.accessToken) {
				const localVarAccessTokenValue = typeof configuration.accessToken === 'function'
					? configuration.accessToken("palletport_auth", ["write:product", "read:product"])
					: configuration.accessToken;
                localVarHeaderParameter["Authorization"] = "Bearer " + localVarAccessTokenValue;
            }

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"ProductCategory" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductCategoryApi - functional programming interface
 * @export
 */
export const ProductCategoryApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Add a new product Category to marketplace
         * @param {ProductCategory} body ProductCategory object that needs to be added to the marketplace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addProductCategory(body: ProductCategory, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProductCategoryApiFetchParamCreator(configuration).addProductCategory(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Deletes a product Category
         * @param {number} productCategoryId Product Category id to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductCategory(productCategoryId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProductCategoryApiFetchParamCreator(configuration).deleteProductCategory(productCategoryId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Returns a single product Category
         * @summary Find product Category by ID
         * @param {number} productCategoryId ID of product Category to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductCategoryById(productCategoryId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ProductCategory> {
            const localVarFetchArgs = ProductCategoryApiFetchParamCreator(configuration).getProductCategoryById(productCategoryId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Updates a product Category in the store with form data
         * @param {ProductCategory} body ProductCategory object that needs to be added to the marketplace
         * @param {number} productCategoryId ID of product Category that needs to be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProductCategoryWithForm(body: ProductCategory, productCategoryId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ProductCategoryApiFetchParamCreator(configuration).updateProductCategoryWithForm(body, productCategoryId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ProductCategoryApi - factory interface
 * @export
 */
export const ProductCategoryApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Add a new product Category to marketplace
         * @param {ProductCategory} body ProductCategory object that needs to be added to the marketplace
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addProductCategory(body: ProductCategory, options?: any) {
            return ProductCategoryApiFp(configuration).addProductCategory(body, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Deletes a product Category
         * @param {number} productCategoryId Product Category id to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteProductCategory(productCategoryId: number, options?: any) {
            return ProductCategoryApiFp(configuration).deleteProductCategory(productCategoryId, options)(fetch, basePath);
        },
        /**
         * Returns a single product Category
         * @summary Find product Category by ID
         * @param {number} productCategoryId ID of product Category to return
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductCategoryById(productCategoryId: number, options?: any) {
            return ProductCategoryApiFp(configuration).getProductCategoryById(productCategoryId, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Updates a product Category in the store with form data
         * @param {ProductCategory} body ProductCategory object that needs to be added to the marketplace
         * @param {number} productCategoryId ID of product Category that needs to be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProductCategoryWithForm(body: ProductCategory, productCategoryId: number, options?: any) {
            return ProductCategoryApiFp(configuration).updateProductCategoryWithForm(body, productCategoryId, options)(fetch, basePath);
        },
    };
};

/**
 * ProductCategoryApi - object-oriented interface
 * @export
 * @class ProductCategoryApi
 * @extends {BaseAPI}
 */
export class ProductCategoryApi extends BaseAPI {
    /**
     * 
     * @summary Add a new product Category to marketplace
     * @param {ProductCategory} body ProductCategory object that needs to be added to the marketplace
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductCategoryApi
     */
    public addProductCategory(body: ProductCategory, options?: any) {
        return ProductCategoryApiFp(this.configuration).addProductCategory(body, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Deletes a product Category
     * @param {number} productCategoryId Product Category id to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductCategoryApi
     */
    public deleteProductCategory(productCategoryId: number, options?: any) {
        return ProductCategoryApiFp(this.configuration).deleteProductCategory(productCategoryId, options)(this.fetch, this.basePath);
    }

    /**
     * Returns a single product Category
     * @summary Find product Category by ID
     * @param {number} productCategoryId ID of product Category to return
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductCategoryApi
     */
    public getProductCategoryById(productCategoryId: number, options?: any) {
        return ProductCategoryApiFp(this.configuration).getProductCategoryById(productCategoryId, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Updates a product Category in the store with form data
     * @param {ProductCategory} body ProductCategory object that needs to be added to the marketplace
     * @param {number} productCategoryId ID of product Category that needs to be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductCategoryApi
     */
    public updateProductCategoryWithForm(body: ProductCategory, productCategoryId: number, options?: any) {
        return ProductCategoryApiFp(this.configuration).updateProductCategoryWithForm(body, productCategoryId, options)(this.fetch, this.basePath);
    }

}
/**
 * UserApi - fetch parameter creator
 * @export
 */
export const UserApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * This can only be done by the logged in Admin.
         * @summary Create user
         * @param {User} body Created user object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(body: User, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling createUser.');
            }
            const localVarPath = `/users`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This can only be done by the logged in user.
         * @summary Delete user
         * @param {string} userEmail The userEmail that needs to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(userEmail: string, options: any = {}): FetchArgs {
            // verify required parameter 'userEmail' is not null or undefined
            if (userEmail === null || userEmail === undefined) {
                throw new RequiredError('userEmail','Required parameter userEmail was null or undefined when calling deleteUser.');
            }
            const localVarPath = `/users/{userEmail}`
                .replace(`{${"userEmail"}}`, encodeURIComponent(String(userEmail)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user by userEmail
         * @param {string} userEmail The userEmail that needs to be fetched. Use user1@gmail.com for testing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserByUserEmail(userEmail: string, options: any = {}): FetchArgs {
            // verify required parameter 'userEmail' is not null or undefined
            if (userEmail === null || userEmail === undefined) {
                throw new RequiredError('userEmail','Required parameter userEmail was null or undefined when calling getUserByUserEmail.');
            }
            const localVarPath = `/users/{userEmail}`
                .replace(`{${"userEmail"}}`, encodeURIComponent(String(userEmail)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all Users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(options: any = {}): FetchArgs {
            const localVarPath = `/users`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Logs user into the system
         * @param {string} userEmail The user email for login
         * @param {string} password The password for login in clear text
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginUser(userEmail: string, password: string, options: any = {}): FetchArgs {
            // verify required parameter 'userEmail' is not null or undefined
            if (userEmail === null || userEmail === undefined) {
                throw new RequiredError('userEmail','Required parameter userEmail was null or undefined when calling loginUser.');
            }
            // verify required parameter 'password' is not null or undefined
            if (password === null || password === undefined) {
                throw new RequiredError('password','Required parameter password was null or undefined when calling loginUser.');
            }
            const localVarPath = `/users/login`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userEmail !== undefined) {
                localVarQueryParameter['userEmail'] = userEmail;
            }

            if (password !== undefined) {
                localVarQueryParameter['password'] = password;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Logs out current logged in user session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutUser(options: any = {}): FetchArgs {
            const localVarPath = `/users/logout`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Register user into the system
         * @param {string} userEmail The user email for register
         * @param {string} password The password for register in clear text
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUser(userEmail: string, password: string, options: any = {}): FetchArgs {
            // verify required parameter 'userEmail' is not null or undefined
            if (userEmail === null || userEmail === undefined) {
                throw new RequiredError('userEmail','Required parameter userEmail was null or undefined when calling registerUser.');
            }
            // verify required parameter 'password' is not null or undefined
            if (password === null || password === undefined) {
                throw new RequiredError('password','Required parameter password was null or undefined when calling registerUser.');
            }
            const localVarPath = `/users/register`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userEmail !== undefined) {
                localVarQueryParameter['userEmail'] = userEmail;
            }

            if (password !== undefined) {
                localVarQueryParameter['password'] = password;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * This can only be done by the logged in user.
         * @summary Update user
         * @param {User} body Updated user object
         * @param {string} userEmail userEmail that need to be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(body: User, userEmail: string, options: any = {}): FetchArgs {
            // verify required parameter 'body' is not null or undefined
            if (body === null || body === undefined) {
                throw new RequiredError('body','Required parameter body was null or undefined when calling updateUser.');
            }
            // verify required parameter 'userEmail' is not null or undefined
            if (userEmail === null || userEmail === undefined) {
                throw new RequiredError('userEmail','Required parameter userEmail was null or undefined when calling updateUser.');
            }
            const localVarPath = `/users/{userEmail}`
                .replace(`{${"userEmail"}}`, encodeURIComponent(String(userEmail)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter['Content-Type'] = 'application/json';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            const needsSerialization = (<any>"User" !== "string") || localVarRequestOptions.headers['Content-Type'] === 'application/json';
            localVarRequestOptions.body =  needsSerialization ? JSON.stringify(body || {}) : (body || "");

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    return {
        /**
         * This can only be done by the logged in Admin.
         * @summary Create user
         * @param {User} body Created user object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(body: User, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).createUser(body, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This can only be done by the logged in user.
         * @summary Delete user
         * @param {string} userEmail The userEmail that needs to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(userEmail: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).deleteUser(userEmail, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get user by userEmail
         * @param {string} userEmail The userEmail that needs to be fetched. Use user1@gmail.com for testing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserByUserEmail(userEmail: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<User> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).getUserByUserEmail(userEmail, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get all Users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<User>> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).getUsers(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Logs user into the system
         * @param {string} userEmail The user email for login
         * @param {string} password The password for login in clear text
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginUser(userEmail: string, password: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).loginUser(userEmail, password, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Logs out current logged in user session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutUser(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).logoutUser(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Register user into the system
         * @param {string} userEmail The user email for register
         * @param {string} password The password for register in clear text
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUser(userEmail: string, password: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<string> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).registerUser(userEmail, password, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * This can only be done by the logged in user.
         * @summary Update user
         * @param {User} body Updated user object
         * @param {string} userEmail userEmail that need to be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(body: User, userEmail: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UserApiFetchParamCreator(configuration).updateUser(body, userEmail, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * This can only be done by the logged in Admin.
         * @summary Create user
         * @param {User} body Created user object
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUser(body: User, options?: any) {
            return UserApiFp(configuration).createUser(body, options)(fetch, basePath);
        },
        /**
         * This can only be done by the logged in user.
         * @summary Delete user
         * @param {string} userEmail The userEmail that needs to be deleted
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(userEmail: string, options?: any) {
            return UserApiFp(configuration).deleteUser(userEmail, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get user by userEmail
         * @param {string} userEmail The userEmail that needs to be fetched. Use user1@gmail.com for testing.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserByUserEmail(userEmail: string, options?: any) {
            return UserApiFp(configuration).getUserByUserEmail(userEmail, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get all Users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUsers(options?: any) {
            return UserApiFp(configuration).getUsers(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Logs user into the system
         * @param {string} userEmail The user email for login
         * @param {string} password The password for login in clear text
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginUser(userEmail: string, password: string, options?: any) {
            return UserApiFp(configuration).loginUser(userEmail, password, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Logs out current logged in user session
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logoutUser(options?: any) {
            return UserApiFp(configuration).logoutUser(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Register user into the system
         * @param {string} userEmail The user email for register
         * @param {string} password The password for register in clear text
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerUser(userEmail: string, password: string, options?: any) {
            return UserApiFp(configuration).registerUser(userEmail, password, options)(fetch, basePath);
        },
        /**
         * This can only be done by the logged in user.
         * @summary Update user
         * @param {User} body Updated user object
         * @param {string} userEmail userEmail that need to be updated
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(body: User, userEmail: string, options?: any) {
            return UserApiFp(configuration).updateUser(body, userEmail, options)(fetch, basePath);
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * This can only be done by the logged in Admin.
     * @summary Create user
     * @param {User} body Created user object
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public createUser(body: User, options?: any) {
        return UserApiFp(this.configuration).createUser(body, options)(this.fetch, this.basePath);
    }

    /**
     * This can only be done by the logged in user.
     * @summary Delete user
     * @param {string} userEmail The userEmail that needs to be deleted
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public deleteUser(userEmail: string, options?: any) {
        return UserApiFp(this.configuration).deleteUser(userEmail, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get user by userEmail
     * @param {string} userEmail The userEmail that needs to be fetched. Use user1@gmail.com for testing.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserByUserEmail(userEmail: string, options?: any) {
        return UserApiFp(this.configuration).getUserByUserEmail(userEmail, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get all Users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUsers(options?: any) {
        return UserApiFp(this.configuration).getUsers(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Logs user into the system
     * @param {string} userEmail The user email for login
     * @param {string} password The password for login in clear text
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public loginUser(userEmail: string, password: string, options?: any) {
        return UserApiFp(this.configuration).loginUser(userEmail, password, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Logs out current logged in user session
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public logoutUser(options?: any) {
        return UserApiFp(this.configuration).logoutUser(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Register user into the system
     * @param {string} userEmail The user email for register
     * @param {string} password The password for register in clear text
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public registerUser(userEmail: string, password: string, options?: any) {
        return UserApiFp(this.configuration).registerUser(userEmail, password, options)(this.fetch, this.basePath);
    }

    /**
     * This can only be done by the logged in user.
     * @summary Update user
     * @param {User} body Updated user object
     * @param {string} userEmail userEmail that need to be updated
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public updateUser(body: User, userEmail: string, options?: any) {
        return UserApiFp(this.configuration).updateUser(body, userEmail, options)(this.fetch, this.basePath);
    }

}
